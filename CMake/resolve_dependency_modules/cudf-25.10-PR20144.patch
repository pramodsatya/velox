--- a/cpp/src/io/parquet/bloom_filter_reader.cu
+++ b/cpp/src/io/parquet/bloom_filter_reader.cu
@@ -210,13 +210,21 @@ class bloom_filter_expression_converter : public equality_literals_collector {
     auto const op       = expr.get_operator();
 
     if (auto* v = dynamic_cast<ast::column_reference const*>(&operands[0].get())) {
-      // First operand should be column reference, second should be literal.
-      CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 2,
-                   "Only binary operations are supported on column reference");
-      CUDF_EXPECTS(dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
+      // First operand should be column reference, second (if binary operation) should be literal.
+      CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                     cudf::ast::detail::ast_operator_arity(op) == 2,
+                   "Only unary and binary operations are supported on column reference");
+      CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                     dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
                    "Second operand of binary operation with column reference must be a literal");
       v->accept(*this);
 
+      // Propagate the `_always_true` as expression to its unary operator parent
+      if (cudf::ast::detail::ast_operator_arity(op) == 1) {
+        _bloom_filter_expr.push(ast::operation{ast_operator::IDENTITY, _always_true});
+        return _always_true;
+      }
+
       if (op == ast_operator::EQUAL) {
         // Search the literal in this input column's equality literals list and add to the offset.
         auto const col_idx            = v->get_column_index();
@@ -232,18 +240,24 @@ class bloom_filter_expression_converter : public equality_literals_collector {
         auto const& value = _bloom_filter_expr.push(ast::column_reference{col_literal_offset});
         _bloom_filter_expr.push(ast::operation{ast_operator::IDENTITY, value});
       }
-      // For all other expressions, push an always true expression
+      // For all other expressions, push the `_always_true` expression
       else {
-        _bloom_filter_expr.push(
-          ast::operation{ast_operator::NOT,
-                         _bloom_filter_expr.push(ast::operation{ast_operator::NOT, _always_true})});
+        _bloom_filter_expr.push(ast::operation{ast_operator::IDENTITY, _always_true});
       }
     } else {
       auto new_operands = visit_operands(operands);
       if (cudf::ast::detail::ast_operator_arity(op) == 2) {
         _bloom_filter_expr.push(ast::operation{op, new_operands.front(), new_operands.back()});
       } else if (cudf::ast::detail::ast_operator_arity(op) == 1) {
-        _bloom_filter_expr.push(ast::operation{op, new_operands.front()});
+        // If the new_operands is just a `_always_true` literal, propagate it here
+        if (auto* lit = dynamic_cast<ast::literal const*>(&new_operands.front().get());
+            lit == &_always_true) {
+          _bloom_filter_expr.push(
+            ast::operation{ast_operator::IDENTITY, _bloom_filter_expr.back()});
+          return _always_true;
+        } else {
+          _bloom_filter_expr.push(ast::operation{op, new_operands.front()});
+        }
       }
     }
     return _bloom_filter_expr.back();
@@ -622,17 +636,23 @@ std::reference_wrapper<ast::expression const> equality_literals_collector::visit
   auto const op       = expr.get_operator();
 
   if (auto* v = dynamic_cast<ast::column_reference const*>(&operands[0].get())) {
-    // First operand should be column reference, second should be literal.
-    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 2,
-                 "Only binary operations are supported on column reference");
-    auto const literal_ptr = dynamic_cast<ast::literal const*>(&operands[1].get());
-    CUDF_EXPECTS(literal_ptr != nullptr,
+    // First operand should be column reference, second (if binary operation) should be literal.
+    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                   cudf::ast::detail::ast_operator_arity(op) == 2,
+                 "Only unary and binary operations are supported on column reference");
+    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                   dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
                  "Second operand of binary operation with column reference must be a literal");
+
     v->accept(*this);
 
+    // Return early if this is a unary operation
+    if (cudf::ast::detail::ast_operator_arity(op) == 1) { return expr; }
+
     // Push to the corresponding column's literals list iff equality predicate is seen
     if (op == ast_operator::EQUAL) {
-      auto const col_idx = v->get_column_index();
+      auto const literal_ptr = dynamic_cast<ast::literal const*>(&operands[1].get());
+      auto const col_idx     = v->get_column_index();
       _literals[col_idx].emplace_back(const_cast<ast::literal*>(literal_ptr));
     }
   } else {
--- a/cpp/src/io/parquet/experimental/dictionary_page_filter.cu
+++ b/cpp/src/io/parquet/experimental/dictionary_page_filter.cu
@@ -1407,13 +1407,21 @@ class dictionary_expression_converter : public equality_literals_collector {
     auto const op       = expr.get_operator();
 
     if (auto* v = dynamic_cast<ast::column_reference const*>(&operands[0].get())) {
-      // First operand should be column reference, second should be literal.
-      CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 2,
-                   "Only binary operations are supported on column reference");
-      CUDF_EXPECTS(dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
+      // First operand should be column reference, second (if binary operation) should be literal.
+      CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                     cudf::ast::detail::ast_operator_arity(op) == 2,
+                   "Only unary and binary operations are supported on column reference");
+      CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                     dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
                    "Second operand of binary operation with column reference must be a literal");
       v->accept(*this);
 
+      // Propagate the `_always_true` as expression to its unary operator parent
+      if (cudf::ast::detail::ast_operator_arity(op) == 1) {
+        _dictionary_expr.push(ast::operation{ast_operator::IDENTITY, _always_true});
+        return _always_true;
+      }
+
       if (op == ast_operator::EQUAL or op == ast::ast_operator::NOT_EQUAL) {
         // Search the literal in this input column's equality literals list and add to
         // the offset.
@@ -1440,7 +1448,7 @@ class dictionary_expression_converter : public equality_literals_collector {
           _dictionary_expr.push(ast::operation{ast_operator::IDENTITY, value});
         }
       }
-      // For all other expressions, push the `always true` expression
+      // For all other expressions, push the `_always_true` expression
       else {
         _dictionary_expr.push(ast::operation{ast_operator::IDENTITY, _always_true});
       }
@@ -1449,7 +1457,14 @@ class dictionary_expression_converter : public equality_literals_collector {
       if (cudf::ast::detail::ast_operator_arity(op) == 2) {
         _dictionary_expr.push(ast::operation{op, new_operands.front(), new_operands.back()});
       } else if (cudf::ast::detail::ast_operator_arity(op) == 1) {
-        _dictionary_expr.push(ast::operation{op, new_operands.front()});
+        // If the new_operands is just a `_always_true` literal, propagate it here
+        if (auto* lit = dynamic_cast<ast::literal const*>(&new_operands.front().get());
+            lit == &_always_true) {
+          _dictionary_expr.push(ast::operation{ast_operator::IDENTITY, _dictionary_expr.back()});
+          return _always_true;
+        } else {
+          _dictionary_expr.push(ast::operation{op, new_operands.front()});
+        }
       }
     }
     return _dictionary_expr.back();
@@ -1579,18 +1594,23 @@ std::reference_wrapper<ast::expression const> dictionary_literals_collector::vis
   auto const op       = expr.get_operator();
 
   if (auto* v = dynamic_cast<ast::column_reference const*>(&operands[0].get())) {
-    // First operand should be column reference, second should be literal.
-    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 2,
-                 "Only binary operations are supported on column reference");
-    auto const literal_ptr = dynamic_cast<ast::literal const*>(&operands[1].get());
-    CUDF_EXPECTS(literal_ptr != nullptr,
+    // First operand should be column reference, second (if binary operation) should be literal.
+    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                   cudf::ast::detail::ast_operator_arity(op) == 2,
+                 "Only unary and binary operations are supported on column reference");
+    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                   dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
                  "Second operand of binary operation with column reference must be a literal");
     v->accept(*this);
 
+    // Return early if this is a unary operation
+    if (cudf::ast::detail::ast_operator_arity(op) == 1) { return expr; }
+
     // Push to the corresponding column's literals and operators list iff EQUAL or NOT_EQUAL
     // operator is seen
     if (op == ast_operator::EQUAL or op == ast::ast_operator::NOT_EQUAL) {
-      auto const col_idx = v->get_column_index();
+      auto const literal_ptr = dynamic_cast<ast::literal const*>(&operands[1].get());
+      auto const col_idx     = v->get_column_index();
       _literals[col_idx].emplace_back(const_cast<ast::literal*>(literal_ptr));
       _operators[col_idx].emplace_back(op);
     }
--- a/cpp/src/io/parquet/experimental/page_index_filter.cu
+++ b/cpp/src/io/parquet/experimental/page_index_filter.cu
@@ -442,7 +442,7 @@ struct page_stats_caster : public stats_caster_base {
    * @return A pair of device columns with min and max value from page statistics for each row
    */
   template <typename T>
-  std::pair<std::unique_ptr<column>, std::unique_ptr<column>> operator()(
+  std::tuple<std::unique_ptr<column>, std::unique_ptr<column>, std::unique_ptr<column>> operator()(
     cudf::size_type schema_idx,
     cudf::data_type dtype,
     rmm::cuda_stream_view stream,
@@ -465,6 +465,7 @@ struct page_stats_caster : public stats_caster_base {
       // Create host columns with page-level min, max values
       host_column<T> min(total_pages, stream);
       host_column<T> max(total_pages, stream);
+      host_column<bool> is_null(total_pages, stream);
 
       // Populate the host columns with page-level min, max statistics from the page index
       auto page_offset_idx = 0;
@@ -490,18 +491,34 @@ struct page_stats_caster : public stats_caster_base {
             auto const page_offset_in_colchunk = col_chunk_page_offsets[page_offset_idx++];
 
             // For all pages in this column chunk
-            std::for_each(
-              thrust::counting_iterator<size_t>(0),
-              thrust::counting_iterator(num_pages_in_colchunk),
-              [&](auto page_idx) {
-                auto const& min_value = column_index.min_values[page_idx];
-                auto const& max_value = column_index.max_values[page_idx];
-                // Translate binary data to Type then to <T>
-                min.set_index(
-                  page_offset_in_colchunk + page_idx, min_value, colchunk.meta_data.type);
-                max.set_index(
-                  page_offset_in_colchunk + page_idx, max_value, colchunk.meta_data.type);
-              });
+            std::for_each(thrust::counting_iterator<size_t>(0),
+                          thrust::counting_iterator(num_pages_in_colchunk),
+                          [&](auto page_idx) {
+                            auto const& min_value      = column_index.min_values[page_idx];
+                            auto const& max_value      = column_index.max_values[page_idx];
+                            auto const column_page_idx = page_offset_in_colchunk + page_idx;
+                            // Translate binary data to Type then to <T>
+                            min.set_index(column_page_idx, min_value, colchunk.meta_data.type);
+                            max.set_index(column_page_idx, max_value, colchunk.meta_data.type);
+                            if (column_index.null_pages[page_idx]) {
+                              is_null.val[column_page_idx] = true;
+                              return;
+                            }
+                            if (not column_index.null_counts.has_value()) {
+                              is_null.set_index(column_page_idx, std::nullopt, {});
+                              return;
+                            }
+                            auto const page_row_count = page_row_offsets[column_page_idx + 1] -
+                                                        page_row_offsets[column_page_idx];
+                            auto const& null_count = column_index.null_counts.value()[page_idx];
+                            if (null_count == page_row_count) {
+                              is_null.val[column_page_idx] = false;
+                            } else if (null_count > 0 and null_count < page_row_count) {
+                              is_null.set_index(column_page_idx, std::nullopt, {});
+                            } else {
+                              CUDF_FAIL("Invalid null count");
+                            }
+                          });
           });
         });
 
@@ -513,37 +530,49 @@ struct page_stats_caster : public stats_caster_base {
       // row-level.
       if constexpr (not cuda::std::is_same_v<T, cudf::string_view>) {
         // Move host columns to device
-        auto mincol = min.to_device(dtype, stream, mr);
-        auto maxcol = max.to_device(dtype, stream, mr);
+        auto mincol     = min.to_device(dtype, stream, mr);
+        auto maxcol     = max.to_device(dtype, stream, mr);
+        auto is_nullcol = is_null.to_device(cudf::data_type{cudf::type_id::BOOL8}, stream, mr);
 
         // Convert page-level min and max columns to row-level min and max columns by gathering
         // values based on page-level row offsets
-        auto [min_data, min_bitmask] = build_data_and_nullmask<T>(mincol->mutable_view(),
+        auto [min_data, min_bitmask]   = build_data_and_nullmask<T>(mincol->mutable_view(),
                                                                   min.null_mask.data(),
                                                                   page_indices,
                                                                   page_row_offsets,
                                                                   dtype,
                                                                   stream,
                                                                   mr);
-        auto [max_data, max_bitmask] = build_data_and_nullmask<T>(maxcol->mutable_view(),
+        auto [max_data, max_bitmask]   = build_data_and_nullmask<T>(maxcol->mutable_view(),
                                                                   max.null_mask.data(),
                                                                   page_indices,
                                                                   page_row_offsets,
                                                                   dtype,
                                                                   stream,
                                                                   mr);
+        auto [null_data, null_bitmask] = build_data_and_nullmask<bool>(is_nullcol->mutable_view(),
+                                                                       is_null.null_mask.data(),
+                                                                       page_indices,
+                                                                       page_row_offsets,
+                                                                       dtype,
+                                                                       stream,
+                                                                       mr);
 
         // Count nulls in min and max columns
         auto const min_nulls = cudf::detail::null_count(
           reinterpret_cast<bitmask_type*>(min_bitmask.data()), 0, total_rows, stream);
         auto const max_nulls = cudf::detail::null_count(
           reinterpret_cast<bitmask_type*>(max_bitmask.data()), 0, total_rows, stream);
+        auto const null_nulls = cudf::detail::null_count(
+          reinterpret_cast<bitmask_type*>(null_bitmask.data()), 0, total_rows, stream);
 
-        // Return min and max device columns
+        // Return min, max and is_null device columns
         return {std::make_unique<column>(
                   dtype, total_rows, std::move(min_data), std::move(min_bitmask), min_nulls),
                 std::make_unique<column>(
-                  dtype, total_rows, std::move(max_data), std::move(max_bitmask), max_nulls)};
+                  dtype, total_rows, std::move(max_data), std::move(max_bitmask), max_nulls),
+                std::make_unique<column>(
+                  dtype, total_rows, std::move(null_data), std::move(null_bitmask), null_nulls)};
       }
       // For strings columns, gather the page-level string offsets and bitmask to row-level
       // directly and gather string chars using a batched memcpy.
@@ -552,14 +581,19 @@ struct page_stats_caster : public stats_caster_base {
           min.val, min.chars, min.null_mask.data(), page_indices, page_row_offsets, stream, mr);
         auto [max_data, max_offsets, max_nullmask] = build_string_data_and_nullmask(
           max.val, max.chars, max.null_mask.data(), page_indices, page_row_offsets, stream, mr);
+        auto is_nullcol = is_null.to_device(cudf::data_type{cudf::type_id::BOOL8}, stream, mr);
+        auto [null_data, null_bitmask] = build_data_and_nullmask<bool>(
+          is_nullcol->mutable_view(), {}, page_indices, page_row_offsets, dtype, stream, mr);
 
         // Count nulls in min and max columns
         auto const min_nulls = cudf::detail::null_count(
           reinterpret_cast<bitmask_type*>(min_nullmask.data()), 0, total_rows, stream);
         auto const max_nulls = cudf::detail::null_count(
           reinterpret_cast<bitmask_type*>(max_nullmask.data()), 0, total_rows, stream);
+        auto const null_nulls = cudf::detail::null_count(
+          reinterpret_cast<bitmask_type*>(null_bitmask.data()), 0, total_rows, stream);
 
-        // Return min and max device strings columns
+        // Return min, max and is_null device strings columns
         return {
           cudf::make_strings_column(
             total_rows,
@@ -572,7 +606,9 @@ struct page_stats_caster : public stats_caster_base {
             std::make_unique<column>(std::move(max_offsets), rmm::device_buffer{0, stream, mr}, 0),
             std::move(max_data),
             max_nulls,
-            std::move(max_nullmask))};
+            std::move(max_nullmask)),
+          std::make_unique<column>(
+            dtype, total_rows, std::move(null_data), std::move(null_bitmask), null_nulls)};
       }
     }
   }
@@ -644,11 +680,22 @@ std::unique_ptr<cudf::column> aggregate_reader_metadata::build_row_mask_with_pag
   auto const num_columns = output_dtypes.size();
 
   // Get a boolean mask indicating which columns will participate in stats based filtering
-  auto const stats_columns_mask =
+  auto const [stats_columns_mask, has_is_null_operator] =
     parquet::detail::stats_columns_collector{filter.get(),
                                              static_cast<size_type>(output_dtypes.size())}
       .get_stats_columns_mask();
 
+  // Return early if no columns will participate in stats based page filtering
+  if (stats_columns_mask.empty()) {
+    auto row_mask = cudf::make_numeric_column(
+      data_type{cudf::type_id::BOOL8}, total_rows, rmm::device_buffer{}, 0, stream, mr);
+    thrust::fill(rmm::exec_policy_nosync(stream),
+                 row_mask->mutable_view().begin<bool>(),
+                 row_mask->mutable_view().end<bool>(),
+                 true);
+    return row_mask;
+  }
+
   // Convert page statistics to a table
   // where min(col[i]) = columns[i*2], max(col[i])=columns[i*2+1]
   // For each column, it contains total number of rows from all row groups.
@@ -670,12 +717,15 @@ std::unique_ptr<cudf::column> aggregate_reader_metadata::build_row_mask_with_pag
           data_type{cudf::type_id::BOOL8}, total_rows, rmm::device_buffer{}, 0, stream, mr));
         columns.push_back(cudf::make_numeric_column(
           data_type{cudf::type_id::BOOL8}, total_rows, rmm::device_buffer{}, 0, stream, mr));
+        columns.push_back(cudf::make_numeric_column(
+          data_type{cudf::type_id::BOOL8}, total_rows, rmm::device_buffer{}, 0, stream, mr));
         return;
       }
-      auto [min_col, max_col] = cudf::type_dispatcher<dispatch_storage_type>(
+      auto [min_col, max_col, is_null_col] = cudf::type_dispatcher<dispatch_storage_type>(
         dtype, stats_col, schema_idx, dtype, stream, mr);
       columns.push_back(std::move(min_col));
       columns.push_back(std::move(max_col));
+      columns.push_back(std::move(is_null_col));
     });
 
   auto stats_table = cudf::table(std::move(columns));
--- a/cpp/src/io/parquet/predicate_pushdown.cpp
+++ b/cpp/src/io/parquet/predicate_pushdown.cpp
@@ -64,7 +64,7 @@ struct row_group_stats_caster : public stats_caster_base {
 
   // Creates device columns from column statistics (min, max)
   template <typename T>
-  std::pair<std::unique_ptr<column>, std::unique_ptr<column>> operator()(
+  std::tuple<std::unique_ptr<column>, std::unique_ptr<column>, std::unique_ptr<column>> operator()(
     int schema_idx,
     cudf::data_type dtype,
     rmm::cuda_stream_view stream,
@@ -76,6 +76,8 @@ struct row_group_stats_caster : public stats_caster_base {
     } else {
       host_column<T> min(total_row_groups, stream);
       host_column<T> max(total_row_groups, stream);
+      host_column<bool> is_null(total_row_groups, stream);
+
       size_type stats_idx = 0;
       for (size_t src_idx = 0; src_idx < row_group_indices.size(); ++src_idx) {
         for (auto const rg_idx : row_group_indices[src_idx]) {
@@ -96,15 +98,31 @@ struct row_group_stats_caster : public stats_caster_base {
             // translate binary data to Type then to <T>
             min.set_index(stats_idx, min_value, colchunk.meta_data.type);
             max.set_index(stats_idx, max_value, colchunk.meta_data.type);
+            // Check the nullability of this column chunk
+            if (colchunk.meta_data.statistics.null_count.has_value()) {
+              auto const& null_count = colchunk.meta_data.statistics.null_count.value();
+              if (null_count == 0) {
+                is_null.val[stats_idx] = false;
+              } else if (null_count < colchunk.meta_data.num_values) {
+                is_null.set_index(stats_idx, std::nullopt, {});
+              } else if (null_count == colchunk.meta_data.num_values) {
+                is_null.val[stats_idx] = true;
+              } else {
+                CUDF_FAIL("Invalid null count");
+              }
+            }
           } else {
             // Marking it null, if column present in row group
             min.set_index(stats_idx, std::nullopt, {});
             max.set_index(stats_idx, std::nullopt, {});
+            is_null.set_index(stats_idx, std::nullopt, {});
           }
           stats_idx++;
         }
       };
-      return {min.to_device(dtype, stream, mr), max.to_device(dtype, stream, mr)};
+      return {min.to_device(dtype, stream, mr),
+              max.to_device(dtype, stream, mr),
+              is_null.to_device(data_type{cudf::type_id::BOOL8}, stream, mr)};
     }
   }
 };
@@ -122,10 +140,13 @@ std::optional<std::vector<std::vector<size_type>>> aggregate_reader_metadata::ap
   auto mr = cudf::get_current_device_resource_ref();
 
   // Get a boolean mask indicating which columns can participate in stats based filtering
-  auto const stats_columns_mask =
+  auto const [stats_columns_mask, has_is_null_operator] =
     stats_columns_collector{filter.get(), static_cast<size_type>(output_dtypes.size())}
       .get_stats_columns_mask();
 
+  // Return early if no columns will participate in stats based filtering
+  if (stats_columns_mask.empty()) { return std::nullopt; }
+
   // Converts Column chunk statistics to a table
   // where min(col[i]) = columns[i*2], max(col[i])=columns[i*2+1]
   // For each column, it contains #sources * #column_chunks_per_src rows
@@ -143,12 +164,15 @@ std::optional<std::vector<std::vector<size_type>>> aggregate_reader_metadata::ap
         data_type{cudf::type_id::BOOL8}, total_row_groups, rmm::device_buffer{}, 0, stream, mr));
       columns.push_back(cudf::make_numeric_column(
         data_type{cudf::type_id::BOOL8}, total_row_groups, rmm::device_buffer{}, 0, stream, mr));
+      columns.push_back(cudf::make_numeric_column(
+        data_type{cudf::type_id::BOOL8}, total_row_groups, rmm::device_buffer{}, 0, stream, mr));
       continue;
     }
-    auto [min_col, max_col] =
+    auto [min_col, max_col, is_null_col] =
       cudf::type_dispatcher<dispatch_storage_type>(dtype, stats_col, schema_idx, dtype, stream, mr);
     columns.push_back(std::move(min_col));
     columns.push_back(std::move(max_col));
+    columns.push_back(std::move(is_null_col));
   }
   auto stats_table = cudf::table(std::move(columns));
 
--- a/cpp/src/io/parquet/stats_filter_helpers.cpp
+++ b/cpp/src/io/parquet/stats_filter_helpers.cpp
@@ -63,17 +63,26 @@ std::reference_wrapper<ast::expression const> stats_columns_collector::visit(
   auto const op       = expr.get_operator();
 
   if (auto* v = dynamic_cast<ast::column_reference const*>(&operands[0].get())) {
-    // First operand should be column reference, second should be literal.
-    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 2,
-                 "Only binary operations are supported on column reference");
-    CUDF_EXPECTS(dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
+    // First operand should be column reference, second (if binary operation)should be literal.
+    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                   cudf::ast::detail::ast_operator_arity(op) == 2,
+                 "Only unary and binary operations are supported on column reference");
+    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                   dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
                  "Second operand of binary operation with column reference must be a literal");
     v->accept(*this);
-    // If this is a supported operation, mark the column as needed
+
+    // Return early if this is a unary operation
+    if (cudf::ast::detail::ast_operator_arity(op) == 1 and op != ast_operator::IS_NULL) {
+      return expr;
+    }
+
+    // Else if this is a supported binary operation, mark the column as needed
     if (op == ast_operator::EQUAL or op == ast_operator::NOT_EQUAL or op == ast_operator::LESS or
         op == ast_operator::LESS_EQUAL or op == ast_operator::GREATER or
-        op == ast_operator::GREATER_EQUAL) {
+        op == ast_operator::GREATER_EQUAL or op == ast_operator::IS_NULL) {
       _columns_mask[v->get_column_index()] = true;
+      if (op == ast_operator::IS_NULL) { _has_is_null_operator = true; }
     } else {
       CUDF_FAIL("Unsupported operation in Statistics AST");
     }
@@ -85,9 +94,9 @@ std::reference_wrapper<ast::expression const> stats_columns_collector::visit(
   return expr;
 }
 
-thrust::host_vector<bool> stats_columns_collector::get_stats_columns_mask() &&
+std::pair<thrust::host_vector<bool>, bool> stats_columns_collector::get_stats_columns_mask() &&
 {
-  return std::move(_columns_mask);
+  return {std::move(_columns_mask), _has_is_null_operator};
 }
 
 std::vector<std::reference_wrapper<ast::expression const>> stats_columns_collector::visit_operands(
@@ -117,15 +126,33 @@ std::reference_wrapper<ast::expression const> stats_expression_converter::visit(
   auto const op       = expr.get_operator();
 
   if (auto* v = dynamic_cast<ast::column_reference const*>(&operands[0].get())) {
-    // First operand should be column reference, second should be literal.
-    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 2,
-                 "Only binary operations are supported on column reference");
-    CUDF_EXPECTS(dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
+    // First operand should be column reference, second (if binary operation) should be literal.
+    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                   cudf::ast::detail::ast_operator_arity(op) == 2,
+                 "Only unary and binary operations are supported on column reference");
+    CUDF_EXPECTS(cudf::ast::detail::ast_operator_arity(op) == 1 or
+                   dynamic_cast<ast::literal const*>(&operands[1].get()) != nullptr,
                  "Second operand of binary operation with column reference must be a literal");
     v->accept(*this);
-    // Push literal into the ast::tree
-    auto const& literal  = _stats_expr.push(*dynamic_cast<ast::literal const*>(&operands[1].get()));
+
     auto const col_index = v->get_column_index();
+
+    if (cudf::ast::detail::ast_operator_arity(op) == 1) {
+      // Evaluate IS_NULL unary operator
+      if (op == ast_operator::IS_NULL) {
+        auto const& vnull = _stats_expr.push(ast::column_reference{col_index * 3 + 2});
+        _stats_expr.push(ast::operation{ast_operator::IDENTITY, vnull});
+        return _stats_expr.back();
+      }  // For all other unary operators, push and return the `_always_true` expression
+      else {
+        _stats_expr.push(ast::operation{ast_operator::IDENTITY, _always_true});
+        // Propagate the `_always_true` as expression to its unary operator parent
+        return _always_true;
+      }
+    }
+
+    // Push literal into the ast::tree
+    auto const& literal = _stats_expr.push(*dynamic_cast<ast::literal const*>(&operands[1].get()));
     switch (op) {
       /* transform to stats conditions. op(col, literal)
       col1 == val --> vmin <= val && vmax >= val
@@ -136,8 +163,8 @@ std::reference_wrapper<ast::expression const> stats_expression_converter::visit(
       col1 <= val --> vmin <= val
       */
       case ast_operator::EQUAL: {
-        auto const& vmin = _stats_expr.push(ast::column_reference{col_index * 2});
-        auto const& vmax = _stats_expr.push(ast::column_reference{col_index * 2 + 1});
+        auto const& vmin = _stats_expr.push(ast::column_reference{col_index * 3});
+        auto const& vmax = _stats_expr.push(ast::column_reference{col_index * 3 + 1});
         _stats_expr.push(ast::operation{
           ast::ast_operator::LOGICAL_AND,
           _stats_expr.push(ast::operation{ast_operator::GREATER_EQUAL, vmax, literal}),
@@ -145,8 +172,8 @@ std::reference_wrapper<ast::expression const> stats_expression_converter::visit(
         break;
       }
       case ast_operator::NOT_EQUAL: {
-        auto const& vmin = _stats_expr.push(ast::column_reference{col_index * 2});
-        auto const& vmax = _stats_expr.push(ast::column_reference{col_index * 2 + 1});
+        auto const& vmin = _stats_expr.push(ast::column_reference{col_index * 3});
+        auto const& vmax = _stats_expr.push(ast::column_reference{col_index * 3 + 1});
         _stats_expr.push(
           ast::operation{ast_operator::LOGICAL_OR,
                          _stats_expr.push(ast::operation{ast_operator::NOT_EQUAL, vmin, vmax}),
@@ -155,24 +182,32 @@ std::reference_wrapper<ast::expression const> stats_expression_converter::visit(
       }
       case ast_operator::LESS: [[fallthrough]];
       case ast_operator::LESS_EQUAL: {
-        auto const& vmin = _stats_expr.push(ast::column_reference{col_index * 2});
+        auto const& vmin = _stats_expr.push(ast::column_reference{col_index * 3});
         _stats_expr.push(ast::operation{op, vmin, literal});
         break;
       }
       case ast_operator::GREATER: [[fallthrough]];
       case ast_operator::GREATER_EQUAL: {
-        auto const& vmax = _stats_expr.push(ast::column_reference{col_index * 2 + 1});
+        auto const& vmax = _stats_expr.push(ast::column_reference{col_index * 3 + 1});
         _stats_expr.push(ast::operation{op, vmax, literal});
         break;
       }
       default: CUDF_FAIL("Unsupported operation in Statistics AST");
     };
+
   } else {
     auto new_operands = visit_operands(operands);
     if (cudf::ast::detail::ast_operator_arity(op) == 2) {
       _stats_expr.push(ast::operation{op, new_operands.front(), new_operands.back()});
     } else if (cudf::ast::detail::ast_operator_arity(op) == 1) {
-      _stats_expr.push(ast::operation{op, new_operands.front()});
+      // If the new_operands is just a `_always_true` literal, propagate it here
+      if (auto* lit = dynamic_cast<ast::literal const*>(&new_operands.front().get());
+          lit == &_always_true) {
+        _stats_expr.push(ast::operation{ast_operator::IDENTITY, _stats_expr.back()});
+        return _always_true;
+      } else {
+        _stats_expr.push(ast::operation{op, new_operands.front()});
+      }
     }
   }
   return _stats_expr.back();
--- a/cpp/src/io/parquet/stats_filter_helpers.hpp
+++ b/cpp/src/io/parquet/stats_filter_helpers.hpp
@@ -266,7 +266,7 @@ class stats_columns_collector : public ast::detail::expression_transformer {
    *
    * @return Boolean vector indicating input columns that can participate in stats based filtering
    */
-  thrust::host_vector<bool> get_stats_columns_mask() &&;
+  std::pair<thrust::host_vector<bool>, bool> get_stats_columns_mask() &&;
 
  protected:
   std::vector<std::reference_wrapper<ast::expression const>> visit_operands(
@@ -276,6 +276,7 @@ class stats_columns_collector : public ast::detail::expression_transformer {
 
  private:
   thrust::host_vector<bool> _columns_mask;
+  bool _has_is_null_operator = false;
 };
 
 /**
@@ -311,6 +312,8 @@ class stats_expression_converter : public stats_columns_collector {
 
  private:
   ast::tree _stats_expr;
+  cudf::numeric_scalar<bool> _always_true_scalar{true};
+  ast::literal const _always_true{_always_true_scalar};
 };
 
 }  // namespace cudf::io::parquet::detail
--- a/cpp/tests/io/parquet_reader_test.cpp
+++ b/cpp/tests/io/parquet_reader_test.cpp
@@ -2844,6 +2844,181 @@ TYPED_TEST(ParquetReaderPredicatePushdownTest, FilterTyped)
   }
 }
 
+template <typename T>
+void filter_unary_operation_typed_test()
+{
+  std::mt19937 gen(0xd00dL);
+  auto [src, filepath, null_count] = [&]() {
+    auto constexpr num_rows            = num_ordered_rows;
+    auto constexpr row_group_size_rows = num_rows / 4;
+    auto _col0                         = testdata::ascending<T>().release();
+    // Add nulls to col0
+    [[maybe_unused]] std::bernoulli_distribution bn(0.7f);
+    auto valids = cudf::detail::make_counting_transform_iterator(0, [&](int index) {
+      return (index >= 2 * row_group_size_rows and index < 3 * row_group_size_rows) ? false : true;
+    });
+    auto [null_mask, null_count] = cudf::test::detail::make_null_mask(valids, valids + num_rows);
+    _col0->set_null_mask(std::move(null_mask), null_count);
+    auto col0                = cudf::purge_nonempty_nulls(_col0->view());
+    auto col1                = testdata::descending<T>();
+    auto col2                = testdata::unordered<T>();
+    auto const written_table = table_view{{col0->view(), col1, col2}};
+    auto const filepath      = temp_env->get_temp_filepath("FilterUnaryOperationTyped.parquet");
+    {
+      cudf::io::table_input_metadata expected_metadata(written_table);
+      expected_metadata.column_metadata[0].set_name("col0");
+      expected_metadata.column_metadata[1].set_name("col1");
+      expected_metadata.column_metadata[2].set_name("col2");
+
+      const cudf::io::parquet_writer_options out_opts =
+        cudf::io::parquet_writer_options::builder(cudf::io::sink_info{filepath}, written_table)
+          .metadata(std::move(expected_metadata))
+          .stats_level(cudf::io::statistics_freq::STATISTICS_COLUMN)
+          .row_group_size_rows(row_group_size_rows);
+      cudf::io::write_parquet(out_opts);
+    }
+
+    std::vector<std::unique_ptr<column>> columns;
+    columns.push_back(std::move(col0));
+    columns.push_back(col1.release());
+    columns.push_back(col2.release());
+
+    return std::tuple{cudf::table{std::move(columns)}, filepath, null_count};
+  }();
+
+  auto const written_table           = src.view();
+  auto const test_predicate_pushdown = [&](cudf::ast::operation const& filter_expression,
+                                           cudf::ast::operation const& ref_filter,
+                                           cudf::size_type expected_total_row_groups,
+                                           cudf::size_type expected_stats_filtered_row_groups,
+                                           std::optional<cudf::size_type> expected_num_rows =
+                                             std::nullopt) {
+    // Expected result
+    auto const predicate = cudf::compute_column(written_table, ref_filter);
+    EXPECT_EQ(predicate->view().type().id(), cudf::type_id::BOOL8)
+      << "Predicate filter should return a boolean";
+    auto const expected = cudf::apply_boolean_mask(written_table, *predicate);
+
+    // JIT does not support nullness-dependent operators such as IS_NULL
+    auto constexpr use_jit = false;
+
+    // Reading with Predicate Pushdown
+    cudf::io::parquet_reader_options read_opts =
+      cudf::io::parquet_reader_options::builder(cudf::io::source_info{filepath})
+        .filter(filter_expression)
+        .use_jit_filter(use_jit);
+    auto const result       = cudf::io::read_parquet(read_opts);
+    auto const result_table = result.tbl->view();
+
+    // Tests
+    if (expected_num_rows.has_value()) {
+      EXPECT_EQ(expected->num_rows(), expected_num_rows.value());
+      EXPECT_EQ(result_table.num_rows(), expected_num_rows.value());
+    }
+    EXPECT_EQ(static_cast<int>(written_table.column(0).type().id()),
+              static_cast<int>(result_table.column(0).type().id()))
+      << "col0 type mismatch";
+    // To make sure AST filters out some elements if row groups must be filtered
+    if (expected_stats_filtered_row_groups < expected_total_row_groups) {
+      EXPECT_LT(expected->num_rows(), written_table.num_rows());
+    } else {
+      EXPECT_LE(expected->num_rows(), written_table.num_rows());
+    }
+    CUDF_TEST_EXPECT_TABLES_EQUAL(expected->view(), result_table);
+    EXPECT_EQ(result.metadata.num_input_row_groups, expected_total_row_groups);
+    EXPECT_TRUE(result.metadata.num_row_groups_after_stats_filter.has_value());
+    EXPECT_EQ(result.metadata.num_row_groups_after_stats_filter.value(),
+              expected_stats_filtered_row_groups);
+    EXPECT_FALSE(result.metadata.num_row_groups_after_bloom_filter.has_value());
+  };
+
+  auto const col_name_0 = cudf::ast::column_name_reference("col0");
+  auto const col_ref_0  = cudf::ast::column_reference(0);
+
+  // Unary operation `IS_NULL` should filter all but one row group and yield exactly `null_count`
+  // rows
+  {
+    auto constexpr expected_total_row_groups          = 4;
+    auto constexpr expected_stats_filtered_row_groups = 1;
+
+    auto const filter_expression =
+      cudf::ast::operation(cudf::ast::ast_operator::IS_NULL, col_name_0);
+    auto const ref_filter = cudf::ast::operation(cudf::ast::ast_operator::IS_NULL, col_ref_0);
+    test_predicate_pushdown(filter_expression,
+                            ref_filter,
+                            expected_total_row_groups,
+                            expected_stats_filtered_row_groups,
+                            null_count);
+  }
+
+  // Unary operation `NOT(IS_NULL)` should filter all but one row group and yield exactly `num_rows
+  // - null_count` rows
+  {
+    auto constexpr expected_total_row_groups          = 4;
+    auto constexpr expected_stats_filtered_row_groups = 3;
+
+    auto const is_null_expr = cudf::ast::operation(cudf::ast::ast_operator::IS_NULL, col_name_0);
+    auto const filter_expression = cudf::ast::operation(cudf::ast::ast_operator::NOT, is_null_expr);
+    auto const is_null_ref_expr = cudf::ast::operation(cudf::ast::ast_operator::IS_NULL, col_ref_0);
+    auto const ref_filter = cudf::ast::operation(cudf::ast::ast_operator::NOT, is_null_ref_expr);
+
+    test_predicate_pushdown(filter_expression,
+                            ref_filter,
+                            expected_total_row_groups,
+                            expected_stats_filtered_row_groups,
+                            num_ordered_rows - null_count);
+  }
+
+  {
+    auto constexpr expected_total_row_groups = 4;
+
+    // Filtering AST
+    auto literal_value = []() {
+      if constexpr (cudf::is_timestamp<T>()) {
+        // table[0] < 10000 timestamp days/seconds/milliseconds/microseconds/nanoseconds
+        return cudf::timestamp_scalar<T>(T(typename T::duration(10000)));  // i (0-20,000)
+      } else if constexpr (cudf::is_duration<T>()) {
+        // table[0] < 10000 day/seconds/milliseconds/microseconds/nanoseconds
+        return cudf::duration_scalar<T>(T(10000));  // i (0-20,000)
+      } else if constexpr (std::is_same_v<T, cudf::string_view>) {
+        // table[0] < "000010000"
+        return cudf::string_scalar("000010000");  // i (0-20,000)
+      } else {
+        // table[0] < 0 or 100u
+        return cudf::numeric_scalar<T>(
+          (100 - 100 * std::is_signed_v<T>));  // i/100 (-100-100/ 0-200)
+      }
+    }();
+
+    auto const literal = cudf::ast::literal(literal_value);
+    auto const expr1   = cudf::ast::operation(cudf::ast::ast_operator::LESS, col_name_0, literal);
+    auto const expr2   = cudf::ast::operation(cudf::ast::ast_operator::IS_NULL, col_name_0);
+
+    auto const ref_expr1 = cudf::ast::operation(cudf::ast::ast_operator::LESS, col_ref_0, literal);
+    auto const ref_expr2 = cudf::ast::operation(cudf::ast::ast_operator::IS_NULL, col_ref_0);
+
+    // col0 < 100 AND IS_NULL(col0)
+    auto filter_expression =
+      cudf::ast::operation(cudf::ast::ast_operator::LOGICAL_AND, expr1, expr2);
+    auto ref_filter =
+      cudf::ast::operation(cudf::ast::ast_operator::LOGICAL_AND, ref_expr1, ref_expr2);
+    auto constexpr expected_filtered_row_groups_with_unary_and = 1;
+    test_predicate_pushdown(filter_expression,
+                            ref_filter,
+                            expected_total_row_groups,
+                            expected_filtered_row_groups_with_unary_and);
+
+    // col0 < 100 OR IS_NULL(col0)
+    filter_expression = cudf::ast::operation(cudf::ast::ast_operator::LOGICAL_OR, expr1, expr2);
+    ref_filter = cudf::ast::operation(cudf::ast::ast_operator::LOGICAL_OR, ref_expr1, ref_expr2);
+    auto constexpr expected_filtered_row_groups_with_unary_or = 3;
+    test_predicate_pushdown(filter_expression,
+                            ref_filter,
+                            expected_total_row_groups,
+                            expected_filtered_row_groups_with_unary_or);
+  }
+}
+
 TEST_P(ParquetDecompressionTest, RoundTripBasic)
 {
   auto const compression_type = std::get<1>(GetParam());
